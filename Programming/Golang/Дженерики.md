Дженерики (generics) позволяют писать обобщённый код, который работает с разными типами без необходимости дублирования кода.

До появления дженериков приходилось использовать `interface{}` и [[Утверждение типа]] для обобщённого кода, что было:
- Неудобно (нужно вручную проверять тип).
- Менее производительно (из-за динамических преобразований).
- Менее безопасно (ошибки выявлялись только во время выполнения, а не на этапе компиляции).


## Обобщённые функции
Синтаксис дженериков использует **параметры типа** в квадратных скобках `[]`.

Пример: функция, возвращающая большее из двух значений:
```go
package main

import "fmt"

// T — это параметр типа, который мы объявили в скобках
func Max[T int | float64](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(Max(10, 20))       // 20
    fmt.Println(Max(3.5, 2.8))     // 3.5
}
```
Здесь `T` — это **параметр типа**, который может быть `int` или `float64`. Это позволяет использовать `Max()` как для `int`, так и для `float64`.

## Обобщённые структуры
Дженерики можно применять и к структурам.

Пример: обобщённый тип **Box**, который хранит значение любого типа `T`:
```go
package main

import "fmt"

// Обобщённая структура
type Box[T any] struct {
    value T
}

// Метод структуры
func (b Box[T]) GetValue() T {
    return b.value
}

func main() {
    intBox := Box[int]{value: 42}
    strBox := Box[string]{value: "hello"}

    fmt.Println(intBox.GetValue()) // 42
    fmt.Println(strBox.GetValue()) // hello
}
```


## Ограничения типов (Constraints)
В `Max[T]` мы явно указывали `T int | float64`. Однако можно использовать **интерфейсы** для ограничения допустимых типов.

Пример: ограничение через `constraints.Ordered`, который поддерживает сравнение (`<`, `>`, `==`):
```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// Ordered — это интерфейс, включающий сравнимые типы
func Max[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(Max(10, 20))   // 20
    fmt.Println(Max("a", "b")) // b
}
```
Здесь `constraints.Ordered` позволяет использовать `Max()` с `int`, `float64`, `string` и другими сравнимыми типами.

## Обобщённые мапы и срезы
Дженерики работают и с коллекциями данных.

Пример: функция, которая находит элемент в срезе:
```go
package main

import "fmt"

// Функция ищет элемент в срезе
func Contains[T comparable](slice []T, item T) bool {
    for _, v := range slice {
        if v == item {
            return true
        }
    }
    return false
}

func main() {
    fmt.Println(Contains([]int{1, 2, 3}, 2))      // true
    fmt.Println(Contains([]string{"a", "b"}, "c")) // false
}
```

Здесь `comparable` — встроенное ограничение, которое позволяет использовать только **сравнимые** (`==`, `!=`) типы.

## Когда использовать дженерики?
### ✅ Подходят, если:
- Функция или структура должна работать с разными типами.
- Нет необходимости в различном поведении для разных типов.
- Нужно сохранить **безопасность типов**.
### ❌ Не подходят, если:
- Код работает только с одним конкретным типом.
- Для разных типов нужно разное поведение.
- Использование `interface{}` проще и понятнее.

## Вывод
- Дженерики позволяют писать **обобщённые функции и структуры**.
- Используют **параметры типа** `T`.
- Можно ограничивать типы с помощью **интерфейсов**.
- Они **безопаснее и эффективнее** `interface{}`.
- Используйте их **только когда это оправдано**, чтобы не усложнять код.