Дженерики (generics) позволяют писать обобщённый код, который работает с разными типами без необходимости дублирования кода.

До появления дженериков приходилось использовать `interface{}` и [[Утверждение типа]] для обобщённого кода, что было:
- Неудобно (нужно вручную проверять тип).
- Менее производительно (из-за динамических преобразований).
- Менее безопасно (ошибки выявлялись только во время выполнения, а не на этапе компиляции).


## Обобщённые функции
Синтаксис дженериков использует **параметры типа** в квадратных скобках `[]`.

Пример: функция, возвращающая большее из двух значений:
```go
package main

import "fmt"

// T — это параметр типа, который мы объявили в скобках
func Max[T int | float64](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(Max(10, 20))       // 20
    fmt.Println(Max(3.5, 2.8))     // 3.5
}
```
Здесь `T` — это **параметр типа**, который может быть `int` или `float64`. Это позволяет использовать `Max()` как для `int`, так и для `float64`.

## Обобщённые структуры
Дженерики можно применять и к структурам.

Пример: обобщённый тип **Box**, который хранит значение любого типа `T`:
```go
package main

import "fmt"

// Обобщённая структура
type Box[T any] struct {
    value T
}

// Метод структуры
func (b Box[T]) GetValue() T {
    return b.value
}

func main() {
    intBox := Box[int]{value: 42}
    strBox := Box[string]{value: "hello"}

    fmt.Println(intBox.GetValue()) // 42
    fmt.Println(strBox.GetValue()) // hello
}
```


## Ограничения типов (Constraints)
В `Max[T]` мы явно указывали `T int | float64`. Однако можно использовать **интерфейсы** для ограничения допустимых типов.

Пример: ограничение через `constraints.Ordered`, который поддерживает сравнение (`<`, `>`, `==`):
```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// Ordered — это интерфейс, включающий сравнимые типы
func Max[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(Max(10, 20))   // 20
    fmt.Println(Max("a", "b")) // b
}
```

Здесь `constraints.Ordered` позволяет использовать `Max()` с `int`, `float64`, `string` и другими сравнимыми типами.