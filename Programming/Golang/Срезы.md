**Срезы (слайсы)** очень схожи с массивами — это та же последовательность элементов одинакового типа, однако его длинна не фиксирована, а динамична.

При инициализации срезов мы используем пустые квадратные скобки `[]` без явного указания размера.
Также мы можем добавлять элементы к срезу с помощью функции `append()`, которую мы рассмотрим далее.
У срезов есть такие параметры, как длинна и емкость. На примере ниже, после инициализации среза длинна и емкость равна 4.

```go
package main

import "fmt"

func main(){
	todoList := []string{
		"купить пиво",
		"выпить пиво",
		"купить пиво",
		"кириешки",
	}
	fmt.Println(len(todoList)) // Длинна (4)
	fmt.Println(cap(todoList)) // Ёмкость (4)
	
}
```

Длинна — количество заполненных элементов в срезе.
Емкость — количество всех доступных для заполнения элементов в срезе.

Если мы добавим еще один элемент к срезу то длинна станет равна 5, а емкость 8

Почему так? Сейчас разберемся, это также поможет нам понять как работает функция `append()`.

Все дело в том, что срез, по сути, является указателем на уже знакомый нам массив фиксированной длинны. Во время компиляции анализируется количество элементов среза и создается массив с длинной, равной их количеству.

Если при добавлении нового элемента в срез с помощью функции `append()` у массива, который был выделен при инициализации среза, нету места, создается новый массив, с длинною вдвое больше. Все элементы старого массива копируются в новый+ записывается новое значение.

Соответственно, при инициализации нашего среза, его длинна была 4, и емкость тоже 4, т.к массив, на который ссылался срез был длинной в 4 элемента
Когда же мы выполнили функцию append() , то:
	• Новый элемент вышел за рамки длинны массива
	• Создался новый массив, с длинною вдвое больше (4 -> 8)
	• Срез начал ссылаться на новый массив
	• Все значения из старого массива скопировались в новый + добавился еще один элемент

Теперь основанный на этом массиве срез имеет ёмкость 8 и длину 5.
Функция `append()` имеет следующий вид:
```go
func append(slice []Type, elems ...Type) []Type
```

Она принимает срез, и один/несколько элементов того же типа что и сам срез.

Внимание на `...Type` , такая запись в аргументах функции означает, что можно передать один и более элементов этого типа через запятую.

Функция append() не изменяет переданный в аргументах срез, а возвращает новый.
Если мы присвоим результат выполнения этой функции в новый срез, то увидим что старый не изменился.

Все это время мы с вами работали с **анонимными** срезами. Теперь, чтобы лучше понять как срез ссылается на массив, давайте рассмотрим следующий пример.

```go
package main

import "fmt"

func main(){
	todoList := [4]string{
		"закончились кириешки",
		"купить кириешки",
		"купить пива",
		"пиво"
	}

	var tasks []string
	fmt.Println(tasks == nil) // true

	tasks = todoList[1:4]
	fmt.Println(tasks == nil) // false
}
```
Мы создали пустой срез. Когда он не ссылается ни на какой массив, его значение по умолчанию равно `nil` .
Далее мы присвоили ему срез нашего массива с 1 по 4 элемент. Синтаксис `[m:n]` позволяет делать выборку элементов массива или среза от индекса `m` до `n` . Пустые скобки `[:]` означают выборку всех элементов.
После присвоение у среза его указатель ссылается на массив `todoList` , по этому значение среза теперь не равно `nil`.
Если мы изменяем элементы самого массива, на который ссылается срез, то это отображается и на самом срезе.

Поскольку **срез** — это **указатель**, при передаче его в функцию он передается по ссылке. То есть, мы работаем **с той же областью в памяти**, в которой хранятся значения массива, на который ссылается срез.
Изменяя внутри функции переданный срез, мы тем самым **изменяем исходный срез**