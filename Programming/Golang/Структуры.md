Go можно назвать объектно-ориентированным языком, хоть в нем и нету привычных для такого семейства языков классов. Вместо них в Go используются структуры, которые умеют в себе хранить набор разных типов данных.

Структура имеет возможность хранить в себе множество различных типов данных и может описывать какую-либо сущность из реального мира, ее характеристики (поля) и поведение (методы).

Давайте представим что мы разрабатываем программу для учета сотрудников фирмы. У каждого сотрудника есть имя, пол, возраст, должность и зарплата. Чтобы изобразить подобного рода сущность, ни переменные, ни массивы со срезами нам не подойдут. Тут то на помощь и приходят структуры.

Самый базовый синтаксис объявление структур имеет следующий синтаксис
```go
varName := struct{}{}
```

После ключевого слова struct идет 2 пары фигурных скобок. В первой паре необходимо описать саму структуру, ее поля. Во второй паре скобок необходимо уже записать в эти поля значения.

Создадим свою первую структуру, которая описывает сущность сотрудника.
```go
package

import "fmt"

func main(){
	employee := struct{
		name string
		sex bool
		age int
		salary int
	}{}

	fmt.Println(employee) // {name: sex: age:0 salary:0}
}
```

В теле структуры мы объявили имена полей (параметров сущности) и их типы.

Вторые скобки мы оставили пустыми. Как вы можете увидеть в консоле, у переменной employee теперь есть поля, но все они заполнены нулевыми значениями.

```go
	...
	employee := struct{
		name string
		sex bool
		age int
		salary int
	}{
		name: "Вася",
		sex: false,
		age: 20,
		salary: 1500,
	}

	fmt.Println(employee) // {name:Вася sex:false age:20 salary:1500}
```

Теперь же мы присвоили значения полям во вторых скобках, и наша переменная employee больше не пуста

Такое объявление структуры как в примере выше на практике используется достаточно редко. Дело в том, что зачастую мы хотим один раз описать структуру, а дальше создавать в нашей программе неограниченное количество ее экземпляров.

Для этого в Go существует ключевое слово type .

Если мы хотим описать структуру, при этом не создавая новой переменной, то нам стоит воспользоваться следующей конструкцией объявления 
```go
type Name struct{}
```

```go
package

import "fmt"

func main(){
	type employee struct{
		name string
		sex bool
		age int
		salary int
	}{}

	employee1 := employee{
		name: "Вася",
		sex: false,
		age: 20,
		salary: 1500,
	}

	employee2 := employee{
		name: "Петя",
		sex: true,
		age: 22,
		salary: 500,
	}

	fmt.Println(employee1) // {{name:Вася sex:false age:20 salary:1500}
	fmt.Println(employee1) // {{name:Петя sex:true age:22 salary:500}
}
```

В этом примере мы создали новую структуру employee и описали в ней сущность сотрудника. Далее мы создали 2 экземпляра этой структуры, и присвоили полям разные значения.

Также, хочу обратить внимание, что мы объявили структуру внутри функции main(). Это означает, что за границами этой функции мы не сможем создать экземпляр структуры, потому что она находиться только в области видимости main().

Зачастую структуры объявляются вне тела функций, чтобы можно было создать экземпляр в любом месте программы.

Функция `newEmployee` принимает в качестве аргументов параметры структуры и создает новый экземпляр. Такие функции называются **конструкторами** и зачастую записываются как `newНазваниеСтруктуры()` и возвращают новый объект самой структуры.
```go
func newEmployee(name string, sex bool, age, salary int) employee{
	return employee{
		name: name,
		sex: sex,
		age: age,
		salary: salary,
	}
}
```

К отдельным полям объекта можно обращаться по имени поля после точки `employee1.name`

## Методы структур
Cтруктура может иметь параметры (поля) и поведение (методы).

Методы — такие же функции, но которые имеют доступ к полям конкретного объекта и доступны, по аналогии с полями, у самого объекта при обращении через точку.

Объявление методов структур имеет немного различный синтаксис с функциями и выглядит он следующим образом:
```go
func (s structName) methodName(arg1 type, arg2 type ...) returnType {}
```
Где:
	• structName — имя структуры для которой объявляется метод
	• s — так называемый ресивер (или получатель, но я больше люблю использовать английскую терминологию). Вы можете называть его как угодно, но хорошей практикой будет использовать 1–2 символа, которые являются первыми символами названия структуры.
	• Дальше все аналогично объявлению обычной функции.

Объявим метод структуры, которая будет отдавать отформатированную информацию по каждому объекту.
```go
func (e employee) getInfo() string{
	return fmt.Sprintf("Сотрудник: %s\nВозраст: %d\nЗарплата: %d\n", e.name, e.age, e.salary)
}
```
Внутри тела метода обращение к полям происходит через ресивер

## Указатель на структуру
Объекты структур также могут быть указателями. В таком случае, передавая наш объект в другие функции по ссылке, мы сможем менять значения внутри самого объекта, по аналогии со срезами и мапами.

```go
```