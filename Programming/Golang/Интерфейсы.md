Go можно считать объектно-ориентированным, хоть и эта парадигма в нем реализована без привычных для таких языков классов.

**Интерфейс** — это абстрактный тип, который описывает поведение, но не реализовывает его.

Интерфейсы описывают абстракцию (обобщают) поведение других типов. С помощью обобщения интерфейсы позволяют писать более гибкие и адаптируемые функции, не привязанные к деталям одной конкретной реализации. Он не реализовывает, а лишь определяет набор методов, какие сущность данного типа должна реализовать

Структуры и типы могут реализовывать (или имплементировать) некий интерфейс. Тип **соответствует** (удовлетворяет) интерфейсу, если он обладает всеми методами, которые требует интерфейс.

Допустим мы разрабатываем очень простую систему хранения данных для учета сотрудников. Нам нужно уметь сохранять, получать и удалять информацию из этого хранилища по сотрудникам.

Определим интерфейс storage, который описывает поведение хранилища данных, а также сущность сотрудника.

```go
package main

type employee struct {
	id     int
	name   string
	age    string
	salary int
}

type storage interface {
	insert(e employee) error
	get(id int) (employee, error)
	delete(id int) error
}
```

В теле интерфейса мы описали поведение (определили методы) нашего storage. Он должен уметь делать вставку, получение и удаление сотрудников.


---

Однако, когда мы передаём что-то в `interface{}`(пустой интерфейс), мы теряем информацию о конкретном типе. Чтобы её восстановить, используется [[Утверждение типа]]