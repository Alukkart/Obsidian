Go можно считать объектно-ориентированным, хоть и эта парадигма в нем реализована без привычных для таких языков классов.

**Интерфейс** — это абстрактный тип, который описывает поведение, но не реализовывает его.

Интерфейсы описывают абстракцию (обобщают) поведение других типов. С помощью обобщения интерфейсы позволяют писать более гибкие и адаптируемые функции, не привязанные к деталям одной конкретной реализации. Он не реализовывает, а лишь определяет набор методов, какие сущность данного типа должна реализовать

Структуры и типы могут реализовывать (или имплементировать) некий интерфейс. Тип **соответствует** (удовлетворяет) интерфейсу, если он обладает всеми методами, которые требует интерфейс.

Допустим мы разрабатываем очень простую систему хранения данных для учета сотрудников. Нам нужно уметь сохранять, получать и удалять информацию из этого хранилища по сотрудникам.

Давайте определим интерфейс storage, который описывает поведение хранилища данных, а также сущность сотрудника.

```go
package main

type employee struct {
	id     int
	name   string
	age    string
	salary int
}

type storage interface {
	insert(e employee) error
	get(id int) (employee, error)
	delete(id int) error
}
```

В теле интерфейса мы описали поведение (определили методы) нашего storage. Он должен уметь делать вставку, получение и удаление сотрудников.

На данном этапе нас вообще не волнует как это будет реализовано: будем ли мы хранить эти данные в мапе, записывать в файл или использовать стороннюю базу данных. Нам лишь важно чтобы наше хранилище умело делать эти 3 вещи, а как — это уже вопрос реализации.

Создадим структуру, которая будет реализовывать данный интерфейс.

...