Файл `error.js` позволяет мягко обрабатывать ошибки времени выполнения во вложенных роутах:

- автоматически оборачивает сегмент роута и его потомков в [React Error Boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) (предохранитель)
- создает UI ошибки, привязанный к определенному сегменту, используя иерархию файловой системы для настройки детализации
- изолирует ошибки на уровне сегмента, что позволяет нормально функционировать остальной части приложения
- добавляет функционал восстановления после ошибки без полной перезагрузки страницы

Создайте UI ошибки, добавив файл `error.js` в директорию и экспортировав из него компонент по умолчанию.

![[Pasted image 20240820193241.png]]

```tsx
// app/dashboard/error.tsx
'use client' // компоненты `Error` должны быть клиентскими

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // Отправляем ошибку в сервис обработки ошибок
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>Что-то пошло не так</h2>
      <button
        onClick={
          // Пытаемся восстановиться путем повторного рендеринга сегмента
          () => reset()
        }
      >
        Попробовать снова
      </button>
    </div>
  )
}
```

**Как `error.js` работает?**

![[Pasted image 20240820193319.png]]

- `error.js` автоматически создает предохранитель, оборачивающий вложенный дочерний сегмент или компонент `page.js`
- компонент, экспортируемый из `error.js`, используется в качестве резервного компонента
- при возникновении ошибки внутри предохранителя, ошибка перехватывается? и рендерится резервный компонент
- когда резервный компонент активен, макеты выше предохранителя сохраняют состояние и остаются интерактивными, а компонент ошибки может предоставлять возможности по восстановлению

**Восстановление после ошибки**

Причина ошибки может временной. В этом случае повторное выполнение операции, например, может решить проблему.

Компонент ошибки может использовать функцию `reset` для восстановления. Эта функция повторно рендерит содержимое предохранителя. При успехе резервный компонент ошибки заменяется результатом повторного рендеринга.

```tsx
// app/dashboard/error.tsx
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>Что-то пошло не так</h2>
      <button onClick={() => reset()}>Попробовать снова</button>
    </div>
  )
}
```

**Вложенные роуты**

Компоненты, созданные с помощью специальных файлов, рендерятся в определенном порядке.

Например, вложенный роут с двумя сегментами, включающими `layout.js` и `error.js`, рендерится в такую (упрощенную) иерархию:

![[Pasted image 20240820193358.png]]

Иерархия компонентов влияет на поведение `error.js` во вложенном роуте:

- ошибки всплывают к ближайшему родительскому предохранителю. Это означает, что `error.js` будет обрабатывать ошибки всех вложенных дочерних сегментов. Детализация UI ошибки достигается размещением файлов `error.js` на разных уровнях (в разных директориях) роута
- `error.js` не обрабатывает ошибки, возникшие в `layout.js` того же уровня, поскольку предохранитель оборачивается в макет

**Обработка ошибок в макетах**

`error.js` не перехватывает ошибки, возникшие в `layout.js` или `template.js` того же уровня. Это объясняется тем, что `layout.js` или `template.js` содержат важный общий UI для нескольких соседних роутов, который должен функционировать, несмотря на ошибку.

Для обработки ошибок, возникающих в `layout.js` или `template.js`, используется `error.js` родительского сегмента.

Для обработки ошибок, возникающих в корневом макете или шаблоне, используется `global-error.js`.

**Обработка ошибок в корневом макете**

Предохранитель `global-error.js` оборачивает все приложение, его резервный компонент заменяет корневой макет, поэтому он должен содержать теги `<html>` и `<body>`.

`global-error.js` - это наименее детальный UI ошибки, который может рассматриваться на перехватчик всех ошибок приложения. Он не предназначен для частого использования, поскольку большая часть ошибок должна перехватываться и обрабатываться соответствующими `error.js`.

Даже при наличии `global-error.js` рекомендуется определять корневой `error.js`, чей резервный компонент будет рендериться внутри корневого макета - глобальный общий UI и бренд, например, будут сохраняться.

```tsx
// app/global-error.tsx
'use client'

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <html>
      <body>
        <h2>Что-то пошло не так</h2>
        <button onClick={() => reset()}>Попробовать снова</button>
      </body>
    </html>
  )
}
```

**Обработка серверных ошибок**

Если ошибка возникает внутри серверного компонента, Next.js перенаправляет объект `Error` (лишенный конфиденциальной информации об ошибке в производственной среде) в ближайший файл `error.js` в качестве пропа `error`.

В продакшне `Error` содержит только свойства `message` и `digest`. Это мера безопасности, позволяющая избежать утечки потенциально конфиденциальной информации, содержащейся в ошибке.

`message` содержит общее сообщение об ошибке, `digest` - автоматически генерируемый хэш ошибки, который может использоваться для поиска соответствующей ошибки в логах сервера.

В режиме разработки `Error` сериализуется и содержит `message` оригинальной ошибки для облегчения отладки.