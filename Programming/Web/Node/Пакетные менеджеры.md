Во многих приложениях есть однотипные задачи. Часто они уже решены, и это решение можно использовать в своём коде.

Например, многим программам нужно уметь форматировать даты. Когда мы будем писать новое приложение, то лучше взять готовую функцию форматирования дат, чем писать свою — писать своё решение дольше, его нужно тестировать и исправлять баги.

Кусочки кода, которые можно использовать в своём приложении, называют _библиотеками_ или _пакетами_. Для удобной работы с ними существуют пакетные менеджеры (менеджеры зависимостей). Они помогают выбрать версию библиотеки и гарантируют безопасность.

В мире JavaScript есть три популярных менеджера зависимостей — [npm](https://www.npmjs.com/), [pnpm](https://pnpm.io/) и [Yarn](https://yarnpkg.com/). Они очень похожи по функциональности, но у каждого есть свои особенности.

npm — стандартный менеджер пакетов, поэтому будем смотреть на него.

# Как пишется
Для работы с npm нужно установить [Node.js](https://nodejs.org/).

npm хранит список установленных пакетов в файле `package.json` в корне проекта. Этот файл нужно создать командой:
```zsh title="terminal"
npm init
```

После этого можно устанавливать библиотеки. Например, [`date-fns`](https://date-fns.org/):
```zsh title="terminal"
npm install date-fns

```

Установленные библиотеки можно использовать в своём коде. Если приложение предназначено для работы с [[Node.js]], достаточно просто импортировать пакет в коде:

```js
// Этот код предназначен для Node.js
const dateFns = require('date-fns')

console.log(dateFns.format(new Date(), 'yyyy-MM-dd'))
```

К сожалению, почти все браузеры не умеют работать с библиотеками, установленными через пакетный менеджер. Если приложение должно запускаться в браузере, то для использования пакетов придётся добавить [[Системы сборки]].

# Как понять
>[!info]
Далее в тексте будет упоминаться пакетный менеджер npm, однако похожим образом работают и Yarn и pnpm.

До появления пакетных менеджеров использование сторонних библиотек было сложным. Чтобы добавить такую библиотеку, нужно было найти сайт разработчика, перейти в раздел загрузок, скачать архив с библиотекой, распаковать и, наконец, скопировать к себе в проект. Кроме того, для обновления версий библиотек нужно было вновь пройтись по всем сайтам, понять, вышла ли новая версия библиотеки и что нового в ней появилось, и руками проделать заново весь путь копирования и подключения в проект. Ситуация усугублялась, когда одна библиотека использует код другой библиотеки, то есть «зависит» от неё. И здесь на помощь приходят менеджеры пакетов.

Когда мы добавляем зависимость в проект, `npm` делает под капотом много работы: получает информацию о текущей актуальной версии пакета, получает информацию о зависимостях конкретно этой версии пакета, зависимостях зависимостей и так далее. В результате строится дерево зависимостей — npm собирает воедино всю информацию обо всех необходимых пакетах и их версиях. После этого происходит скачивание пакетов и проверка контрольных сумм. Проверка контрольных сумм нужна для безопасности: это помогает убедиться в том, при скачивании пакета нам его не подменили злоумышленники. После скачивания, как правило, зависимости складываются в папку **node_modules** и становятся готовыми к использованию.

## package.json
`package.json` является важным файлом для проекта - он включает в себя такую информацию, как название проекта, его версия, точка входа (главный файл проекта, с которого начинается запуск программы), скрипты и зависимости.
### Пример файла package.json
```json
{
	"name": "project", // Название проекта
	"version": "0.1.0", // Версия проекта
	"private": true,
	"scripts": {
		"dev": "next dev",
		"build": "next build",
		"start": "next start",
		"lint": "next lint",
		"prisma:push": "prisma db push",
		"prisma:studio": "prisma studio",
		"prisma:seed": "prisma db seed"
	},
	"dependencies": {
		"@hookform/resolvers": "^3.9.0",
		"@prisma/client": "^5.18.0",
		"zod": "^3.23.8",
		"zustand": "^4.5.4"
	},
	"devDependencies": {
		"@types/node": "^20.14.14",
		"eslint": "^8.57.0",
		"postcss": "^8",
		"prisma": "^5.18.0",
		"tailwindcss": "^3.4.1",
		"ts-node": "^10.9.2",
		"typescript": "^5.5.4"
	}
}
```
### Scripts
Сокращения консольных команд
```json
"scripts": {
	"main": "node main.js"
	"название скрипта": "команда которую будет выполнять скрипт"
	...
```

Данный скрип позволит нам написать в консоль `npm run main` вместо `node main.js` , конечно в этом примере такой скрипт нецелесообразен, ведь по своей длине команды примерно одинаковы, но в тех случаях когда вам необходимо использовать длинные команды скрипты могут сильно упростить процесс вызова.

Так же в скриптах можно объединять несколько команд в одну.
Например нам необходимо последовательно запустить 2 файла - сервер(`server.js`) и приложение(`app.js`), тогда мы можем объединить команды запуска этих файлов в скрип и назвать его например `dev`
```json
"scripts": {
	"dev": "node server.js && node app.js"
	...
```

Сравним длину вызова исходной команды и созданного скрипта
```zsh
node server.js && node main.js

npm run dev
```
Согласитесь разница существенная

Самое интересное что скрипты могут вызывать не только команды, но и другие скрипты, тем самым открывая нам дополнительные возможности.

Доработаем ранее созданные скрипты:
```json
"scripts": {
	"main": "node main.js",
	"server": "node server.js",
	"full": "npm run main && server",
}
```

Как мы видим скрип `full` вызывает скрипты `main` и `server`, что позволяет нам соблюдать важный в разработке принцип [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself). 

В реальных проектах скрипты могу выглядеить так:
```json showLineNumbers
"scripts": {
	"format": "prettier --write .",
	"lint": "eslint . --ext .js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix",
	"typecheck": "tsc --noEmit -p tsconfig.node.json --composite false",
	"start": "electron-vite preview",
	"dev": "electron-vite dev",
	"devl": "electron-vite dev --no-sandbox",
	"postinstall": "electron-builder install-app-deps",
	"build": "npm run typecheck && electron-vite build",
	"build:win": "npm run build && electron-builder --win --config",
	"build:mac": "npm run build && electron-builder --mac --config",
	"build:linux": "npm run build && electron-builder --linux --config"
},
```

В этом случае польза скриптов расскрывается на полную мощьность, согласитесь намного проще вызвать скрипт с помощью:
	`npm run lint`
Чем команду:
	`eslint . --ext .js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix`

Так же можно заметить что все скрипты выполняют одну конкретную задачу, а скрипты на строчках 9-12 соединяют простые скрипты в более сложные комбинации, такая структура позволяет быстро вызывать скрипты как по отдельности, так и в заранее созданных вами комбинациях.

### Dependencies(Зависимости)
В этом разделе описаны все установленные вами пакеты с помощью команды `npm i`

Формат записи
```json
"Название пакеты": "Спецификация версии Версия пакета",
"zod": "^3.23.8",
```

В приведенном примере символ ^ - является спецификацией версии, а 3.23.4 самой версией

#### Спецификации версий

| Спецификация | Значение                                                           |
| ------------ | ------------------------------------------------------------------ |
| `~version`   | Приблизительно эквивалентно версии                                 |
| `^version`   | Совместим с версией, т. е. принимаем новую **минор и патч** версии |
| `version`    | Версия должна соответсвовать точно                                 |
| `>version`   | Должна быть больше, чем версия                                     |
| `>=version`  | Должна быть равной или больше версии                               |
| `<version`   | Должна быть меньше, чем версия                                     |
| `<=version`  | Должна быть равной или меньшей версии                              |
| `1.2.x`      | 1.2.0, 1.2.1 и т.д., но не 1.3.0                                   |
| `*`          | Соответствует любой версии                                         |
| `latest`     | Самая свежая версия                                                |

Приведенный выше список не является исчерпывающим.

### DevDependencies

## Лок-файл
Как уже упоминалось, при установке и обновлении пакетов создаётся дерево зависимостей. Пакетный менеджер записывает его в специальный файл — лок-файл (от английского **lock** — зафиксировать). В этом файле содержатся абсолютно все установленные в проекте зависимости с их точными версиями. По этому файлу пакетный менеджер установит точь-в-точь те же пакеты, которые были на момент генерации лок-файла.

>[!info]
>Обязательно фиксируйте лок-файлы в [[Системы управления версиями]]. Это поможет вам создавать воспроизводимые сборки приложения.

Следует помнить, что бывают случаи, когда даже при наличии лок-файла устанавливаются другие версии пакетов. Например, если в списке зависимостей в `package.json` окажется пакет, которого не было на момент генерации лок-файла, то система управления зависимостями заново сгенерирует лок-файл с учётом появившегося пакета.

Разные пакетные менеджеры называют этот файл по-разному: в npm это `package-lock.json`, в pnpm это `pnpm-lock.yaml` а в Yarn —  `yarn.lock`. **Не рекомендуется использовать разные пакетные менеджеры в одном проекте** — один пакетный менеджер может не понять другой лок-файл и установить другие версии библиотек, что может привести к ошибкам в вашем коде.

