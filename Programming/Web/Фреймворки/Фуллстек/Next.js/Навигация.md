Существует 4 способа навигации между роутами:

- компонент `Link`
- хук `useRouter` (клиентские компоненты)
- функция `redirect` (серверные компоненты)
- нативный `History API`

**Компонент `Link`**

`Link` - это встроенный компонент, расширяющий HTML-элемент `a` для предоставления предварительного получения данных (prefetching) и клиентской навигации между роутами. Это основной и рекомендуемый способ навигации между роутами в Next.js.

Этот компонент импортируется из `next/link` и принимает проп `href`:

```tsx
// app/page.tsx
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Панель управления</Link>
}
```

_Примеры_

_Ссылка на динамические сегменты_

При ссылке на динамические сегменты можно использовать шаблонные литералы и интерполяцию для генерации списка ссылок. Пример генерации списка постов блога:

```tsx
// app/blog/PostList.js
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

_Проверка активных ссылок_

Для определения активности ссылки можно использовать хук `usePathname`. Например, для добавления класса к активной ссылке можно проверять совпадение `pathname` со значением пропа `href` ссылки:

```tsx
// app/components/links.tsx
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <ul>
        <li>
          <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
            Главная
          </Link>
        </li>
        <li>
          <Link
            className={`link ${pathname === '/about' ? 'active' : ''}`}
            href="/about"
          >
            Контакты
          </Link>
        </li>
      </ul>
    </nav>
  )
}
```

_Прокрутка к `id`_

Дефолтный поведением роутера приложения является прокрутка в начало новой страницы или сохранение положения прокрутки при навигации вперед-назад.

Для прокрутки к определенному `id` при навигации можно добавить хэш (`#`) к URL или передать хэш в проп `href`. Это возможно благодаря тому, что компонент `Link` рендерится в элемент `a`.

```tsx
<Link href="/dashboard#settings">Настройки</Link>

// Результат
<a href="/dashboard#settings">Настройки</a>
```

_Отключение восстановления прокрутки_

Для отключения дефолтного поведения прокрутки можно передать `scroll={false}` в компонент `Link` или `scroll: false` в методы `router.push` или `router.replace`.

```tsx
// next/link
<Link href="/dashboard" scroll={false}>
  Панель управления
</Link>
```

```tsx
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

**Хук `useRouter`**

Хук `useRouter` позволяет программно менять роуты в клиентских компонентах:

```tsx
// app/page.tsx
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Панель управления
    </button>
  )
}
```

**Функция `redirect`**

В серверных компонентах вместо хука `useRouter` следует использовать функцию `redirect` для программной навигации между роутами:

```tsx
// app/team/[id]/page.tsx
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }: { params: { id: string } }) {
  const team = await fetchTeam(params.id)

  if (!team) {
    redirect('/login')
  }

  // ...
}
```

**Нативный `History API`**

Next.js позволяет использовать нативные методы [window.history.pushState](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) и [window.history.replaceState](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) для обновления стека истории браузера без перезагрузки страницы.

Вызовы методов `pushState` и `replaceState` интегрированы в роутер Next.js, что позволяет выполнять синхронизацию с хуками `usePathname` и `useSearchParams`.

_`window.history.pushState`_

Этот метод позволяет добавлять новую сущность в стек истории браузера. Пользователь может возвращаться к предыдущему состоянию. Пример сортировки списка товаров:

```tsx
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Сортировать по убыванию</button>
      <button onClick={() => updateSorting('desc')}>Сортировать по возрастанию</button>
    </>
  )
}
```

_`window.history.replaceState`_

Этот метод позволяет заменять текущую сущность в стеке истории браузера. Пользователь не может возвращаться к предыдущему состоянию. Пример переключения языка приложения:

```tsx
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // Например, '/en/about' или '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>Английский</button>
      <button onClick={() => switchLocale('fr')}>Французский</button>
    </>
  )
}
```

**Как работают роутинг и навигация?**

Роутер приложения использует гибридный подход для роутинга и навигации. На сервере код приложения автоматически разделяется на части (code splitting) по сегментам роута. На клиенте Next.js предварительно получает данные (prefetching) и кеширует сегменты роута. Это означает, что когда пользователь переходит к новому роуту, браузер не перезагружает страницу, и только изменившиеся сегменты роута рендерятся повторно - это улучшает опыт навигации и производительность.

_1. Разделение кода_

Разделение кода позволяет разделить код приложения на небольшие части (chunks) для загрузки и выполнения браузером. Это уменьшает количество передаваемых данных и время выполнения каждого запроса, что улучшает производительность.

Серверные компоненты позволяют автоматически разделять код по сегментам роута. Это означает, что при навигации загружается только код, необходимый для текущего роута.

_2. Предварительное получение данных_

Предварительное получение данных - это способ предварительной загрузки данных роута в фоновом режиме перед посещением роута пользователем.

Существует два способа предварительного получения данных роута:

- компонент `Link` - данные роута автоматически запрашиваются при попадании ссылки в область видимости. Это происходит при загрузке страницы или во время прокрутки
- метод `router.prefetch` - для программного предварительного получения данных роута может использоваться роутер, возвращаемый хуком `useRouter`

Поведение `Link` в части предварительного получения данных различается для статических и динамических роутов:

- статические роуты - значением `prefetch` по умолчанию является `true`. Весь роут предварительно запрашивается и кешируется
- динамические роуты - только общий макет дерева компонентов до первого файла `loading.js` предварительно запрашивается и кешируется на `30 секунд`. Это уменьшает цену запроса всего динамического роута и позволяет незамедлительно отображать состояние загрузки для лучшего визуального отклика на действия пользователей

Предварительное получение данных можно отключить путем установки `prefetch` в значение `false`.

_3. Кеширование_

Next.js использует клиентский кеш в памяти, который называется кешем роутера (router cache). При навигации пользователя по приложению полезная нагрузка серверных компонентов, предварительно запрошенных сегментов роута и посещенные роуты записываются в кеш.

Это означает максимальное использование кеша при навигации вместо отправки запросов на сервер - улучшение производительности путем уменьшения количества запросов и передаваемых между клиентом и сервером данных.

_4. Частичный рендеринг_

Частичный рендеринг означает, что при навигации повторно рендерятся только сегменты роута, которые изменились, а любые общие сегменты сохраняются.

Например, при навигации между двумя соседними роутами, `/dashboard/settings` и `/dashboard/analytics`, будут отрендерены страницы `settings` и `analytics`, а общий макет `dashboard` будет сохранен.

![[Pasted image 20240818073555.png]]

Без частичного рендеринга каждая навигация будет приводить к повторному рендерингу всей страницы на клиенте. Рендеринг только изменившихся сегментов уменьшает количество передаваемых данных и время выполнения, что приводит к улучшению производительности.

_5. Мягкая навигация_

Браузеры выполняют "жесткую навигацию" (hard navigation) при переключении между страницами. Роутер приложения Next.js выполняет "мягкую навигацию" (soft navigation) между страницами, обеспечивая повторный рендеринг только изменившихся сегментов роута (частичный рендеринг). Это позволяет сохранять клиентское состояние в процессе навигации.

_6. Навигация вперед-назад_

По умолчанию Next.js сохраняет положение прокрутки для навигации вперед-назад и повторно использует сегменты роута из кеша роутера.