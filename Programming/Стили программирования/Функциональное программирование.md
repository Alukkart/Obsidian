Функциональное программирование — одна из парадигм, которые помогают спроектировать программу так, чтобы она верно отражала эти правила и была устойчивой к изменениям.

>[!info]
>Прочитайте [[Парадигмы программирования]], чтобы узнать про альтернативные подходы и разницу в декларативном и императивном стилях.

# Функция как элемент композиции
Любая система состоит из частей. Программы — тоже системы со своими целями и средствами достижения этих целей. Сопоставление разных частей системы вместе называется _композицией_, а эти части — _элементами композиции_ (composition units).

Добиться хорошей композиции трудно, потому что для этого нужно правильно провести границы между элементами. Правильные границы — очень размытое понятие, но в целом можно выделить несколько свойств и требований:

- Границы должны быть проведены так, чтобы элемент решал только одну проблему, а не несколько (принцип [разделения ответственности](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8)).
- Элементы ничего не должны знать об устройстве других элементов, а общаться они должны через данные ([закон Деметры](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B)).
- Данные и настройки должны быть отделены от кода программы ([The Twelve-Factor App](https://12factor.net/ru/config)).

В функциональном программировании элемент композиции — это функция. Передача данных через несколько вызовов функций — их композиция. Например, если мы хотим к числу 10 прибавить 5, а потом умножить результат на 42, то последовательно вызовем функции `add` и `multiply`:

```js
function add(a, b) {
  return a + b
}

function multiply(a, b) {
  return a * b
}

const result = multiply(add(10, 5), 42)
```

Если разбить процесс на несколько шагов, то сперва мы получим результат сложения, а затем передадим его как аргумент умножения:

```js
const additionResult = add(10, 5)
const finalResult = multiply(additionResult, 42)

```

Такая последовательная передача данных на вход следующей функции и есть простейшая функциональная композиция.

У подобной передачи данных даже есть [математическая основа и нотация](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9), и вaцелом функциональное программирование очень близко к математике. Мы ещё поговорим об этом в конце статьи.

## Чистые функции и побочные эффекты
Чтобы композиция функций была проще и не вызывала проблем, эти функции должны быть чистыми (pure). _Чистая функция_ — это функция, которая не вызывает побочных эффектов (side effects), то есть никак не влияет на состояние внешнего мира.

Чистую функцию можно сравнить с понятием функции из математики: это нечто, что преобразует входные данные по заданным правилам.

> [!info]
> Чистые функции всегда при вводе одинаковых аргументов выдают одинаковый результат. По этому свойству легко отличить чистую функцию от нечистой.

Например, `pureFn()` при вводе 10 и 20 всегда будет возвращать 15, значит она чистая:

```js
function pureFn(a, b) {
  return ((a + b) * a) / b
}
```

А `impureFn()` нечистая — она будет возвращать разные значения, потому что использует случайное число:
```js
function impureFn(a, b) {
  return ((a + b) * a) / Math.random()
}
```

И `alsoImpureFn()` тоже нечистая:
```js
function alsoImpureFn() {
  return Date.now()
}
```

В последних двух случаях функции производят побочные эффекты, потому что обращаются к глобальным объектам [`Math`](https://doka.guide/js/math/) и `Date`. Да, _любое взаимодействие_ с чем-либо «снаружи» функции считается побочным эффектом, даже получение значений.

Дело в том, что мы не знаем, как именно устроены методы `random()` и `now()` в объектах снаружи. Они могут не только возвращать результат, но и менять состояние окружающего мира, например, меняя какую-то переменную.

В примере ниже мы обращаемся к методу `now()`, который всегда возвращает одно и то же значение, но попутно меняет значение переменной `counter`. Если мы не знаем, как устроен метод `now()`, мы не можем гарантировать, что `impureFn()` не имеет побочных эффектов, поэтому считаем её тоже нечистой:

```js
let counter = 0

const FakeDate = {
  now() {
    counter++
    return 42
  },
}

function impureFn() {
  return FakeDate.now()
}

impureFn()
// 42, counter === 1

impureFn()
// 42, counter === 2
```

## Рекурсия
Так как в функциональном программировании нельзя менять состояние, то для итеративных процессов мы не можем применять циклы. Вместо этого нам нужно использовать отображение ([`map()`](https://doka.guide/js/array-map/)) и свёртку ([`reduce()`](https://doka.guide/js/array-reduce/)) или [рекурсию](https://doka.guide/js/recursion/).

Оба способа берут начало в математике. Рекурсия помогает даже выразить некоторые задачи в том виде, в котором они формулируются в математике. Вот, например, рекурсивное вычисление факториала:

```js
function factorial(n) {
  if (n <= 1) {
    return 1
  }

  return n * factorial(n - 1)
}
```

## Функции высших порядков

Иногда нам попадаются почти одинаковые задачи, которые отличаются только деталями. Например, нам может быть нужно достать из массива только отрицательные числа или только чётные числа. Мы могли бы написать нечто вроде:

```js
const list = [-1, 2, 5, -5, 6, 3]

const negative = []
for (const element of list) {
  if (element < 0) {
    negative.push(element)
  }
}

const even = []
for (const element of list) {
  if (element % 2 === 0) {
    even.push(element)
  }
}

// negative: [-1, -5]
// even: [2, 6]

```

Если приглядеться, станет видно, что _схема выполнения_ в обоих случаях одинаковая: «перебрать каждое значение и проверить его по условию». Меняется же лишь условие, по которому мы фильтруем массив:

```js
const filteredList = []

for (const element of someList) {
  if (someCondition) {
    filteredList.push(element)
  }
}
```

Мы бы могли перебор вариантов превратить в другую функцию, в которую бы передавали массив и условие проверки:

```js
const isNegative = (n) => n < 0
const isEven = (n) => n % 2 === 0

const negative = filter(list, isNegative)
const even = filter(list, isEven)
```

Здесь новая функция `filter()`, которая непосредственно перебирает значения. Она принимает на вход массив и функцию-предикат, которая проверяет каждое значение массива по своему условию.

Реализуем `filter()` самостоятельно, чтобы понять, как всё работает. Объявим функцию `filter()`, в которую передадим два аргумента: массив и функцию, проверяющую условие — предикат.

```js
function filter(list, predicate) {}
```


# FDFFASDASD